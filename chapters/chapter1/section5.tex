\section{معرفی کدهای خودتغییر (\lr{Self-Modifying Code})}

کدهای خودتغییر به دسته‌ای از برنامه‌ها اشاره دارند که در زمان اجرا ساختار اجرایی خود را بازنویسی می‌کنند. در معماری رایج سامانه‌های امروزی—که دستور و داده هر دو در یک فضای حافظه ذخیره می‌شوند—برنامه می‌تواند همانند داده‌ها به ناحیهٔ کد دسترسی پیدا کند و بخش‌هایی از آن را تغییر دهد. این ویژگی امکان آن را فراهم می‌کند که نسخهٔ واقعیِ اجرا شده با نسخه‌ای که تحلیل‌گر در فایل دودویی مشاهده می‌کند یکسان نباشد. همین فاصله میان «کد ثابت» و «کد اجرایی» یکی از مهم‌ترین چالش‌ها در حوزهٔ مهندسی معکوس و تحلیل استاتیک به‌شمار می‌رود \cite{anckaert2006model}.

در این الگو، برنامه هنگام اجرا مجموعه‌ای از نوشتن‌ها (\lr{self-writes}) بر روی ناحیهٔ کد انجام می‌دهد. این نوشتن‌ها می‌توانند به‌صورت ساده تنها یک دستور را با نسخهٔ معادل اما متفاوت جایگزین کنند، یا در قالب الگوهای پیشرفته‌تر، مسیرهای کنترلی و بلاک‌های اجرایی جدیدی را ایجاد کنند که فقط در حالت خاصی از اجرای برنامه فعال می‌شوند. به همین دلیل، کد خودتغییر الزاماً به‌معنای تغییر «منطق برنامه» نیست؛ بلکه بیشتر ابزاری برای پنهان‌سازی ساختار واقعی کد و پیچیده‌کردن تحلیل است. رفتار نهایی برنامه ثابت می‌ماند، اما شکل داخلی آن در هر اجرا می‌تواند متفاوت باشد \cite{anckaert2006model}.

از دید فنی، مهم‌ترین پیامد وجود \lr{SMC} این است که بسیاری از دیس‌اسمبلرها و ابزارهای تحلیل استاتیک بر فرض «ثابت بودن کد» تکیه دارند. هنگامی که این فرض نقض می‌شود، ابزار قادر نخواهد بود ساختار واقعی جریان کنترل را به‌درستی بازیابی کند. مطالعات موجود نشان می‌دهد که این تغییرپذیری باعث می‌شود نمایش‌های معمولی مانند \lr{Control Flow Graph} نتوانند وضعیت واقعی برنامه را پوشش دهند، زیرا هر بازنویسی در زمان اجرا می‌تواند نسخهٔ جدیدی از یک بلاک اجرایی ایجاد کند و مسیرهای کنترلی متفاوتی را شکل دهد \cite{anckaert2006model}.

بنابراین، \lr{Self-Modifying Code} نه‌تنها یک تکنیک مخفی‌سازی است، بلکه مسئله‌ای بنیادین برای تحلیل‌گر ایجاد می‌کند: کدی که باید تحلیل شود، در فایل حضور ندارد و تنها در زمان اجرا به‌وجود می‌آید. این ویژگی، \lr{SMC} را به یکی از پرکاربردترین سازوکارهای ضد دیس‌اسمبلی در بدافزارها، محافظ‌های نرم‌افزاری و ابزارهای ضد مهندسی معکوس تبدیل کرده است \cite{anckaert2006model}.

\subsection{مثال ساده از کد خودتغییر (\lr{Self-Modifying Code})}

فرض کن برنامهٔ زیر قرار است در نهایت مقدار \lr{10} را در رجیستر \lr{EAX} قرار دهد، اما نویسندهٔ برنامه می‌خواهد مسیر اصلی کد مخفی بماند؛ بنابراین از \lr{SMC} استفاده می‌کند.

\subsubsection*{مرحلهٔ ۱: کد اولیه (نسخهٔ قابل‌مشاهده در فایل)}

در فایل دودویی (روی دیسک)، کد به این شکل دیده می‌شود:

\begin{LTR}
\begin{verbatim}
MOV EAX, 5
MOV EBX, 5
ADD EAX, EBX      ; انتظار داریم 5 + 5 اجرا شود
JMP END
\end{verbatim}
\end{LTR}

برای تحلیلگر، این یک کد کاملاً معمولی است.

\bigskip\hrule\bigskip

\subsubsection*{مرحلهٔ ۲: بخش خودتغییر (self-write)}

اما بخشی از برنامه پیش از اجرای دستور ADD این تغییر را اعمال می‌کند:

\begin{LTR}
\begin{verbatim}
MOV BYTE PTR [address_of_ADD],     0x90
MOV BYTE PTR [address_of_ADD+1],   0x90
MOV BYTE PTR [address_of_ADD+2],   0x90
\end{verbatim}
\end{LTR}

دستور 0x90 برابر NOP است (هیچ کاری انجام نمی‌دهد).
یعنی برنامه قبل از اجرا دستور اصلی را پاک کرده است.

\bigskip\hrule\bigskip

\subsubsection*{مرحلهٔ ۳: نسخهٔ واقعی که اجرا می‌شود}

وقتی CPU به خط مربوط به ADD می‌رسد، دیگر این دستور وجود ندارد.
نسخهٔ دیده‌شده توسط تحلیلگر:

\begin{LTR}
\begin{verbatim}
ADD EAX, EBX
\end{verbatim}
\end{LTR}

اما نسخهٔ واقعی در حافظه تبدیل شده به:

\begin{LTR}
\begin{verbatim}
NOP
NOP
NOP
\end{verbatim}
\end{LTR}

مقدار نهایی:

\begin{LTR}
\begin{verbatim}
EAX = 5
\end{verbatim}
\end{LTR}

که برابر 10 نیست.

\bigskip\hrule\bigskip

\subsection{معایب مثال سادهٔ SMC}

مثال ساده‌ای که در آن یک دستور \lr{ADD} در زمان اجرا با چند دستور \lr{NOP} جایگزین می‌شود، اگرچه برای معرفی مفهوم \lr{Self-Modifying Code} مفید است، اما از نظر فنی و تحلیلی محدودیت‌های مهمی دارد... \cite{anckaert2006model}

\bigskip\hrule\bigskip

\subsection{مثال علمی از SMC وابسته به زمان اجرا (\lr{Time-Dependent Self-Modifying Code})}

در این مثال، ساختار کد به‌گونه‌ای طراحی شده است که \textbf{دستور واقعی} در زمان اجرا و بر اساس مقدار زمان تولید می‌شود \cite{anckaert2006model}.

\subsection*{مرحلهٔ ۱: کد روی دیسک}

\begin{LTR}
\begin{verbatim}
MOV EAX, [SystemTime]
AND EAX, 1
JZ  EvenPath
JMP OddPath

EvenPath:
  ; encrypted even block
  DB 0xA1, 0x29, 0xF3, 0xC2, 0x18

OddPath:
  ; encrypted odd block
  DB 0x9B, 0x11, 0x84, 0xCC, 0x72
\end{verbatim}
\end{LTR}

نسخه‌های رمز شده‌اند .

\bigskip\hrule\bigskip

\subsection*{مرحلهٔ ۲: انتخاب مسیر}

در زمان اجرا مسیر بر اساس ثانیه انتخاب می‌شود.

\bigskip\hrule\bigskip

\subsection*{مرحلهٔ ۳: تولید کد پویا}

\begin{LTR}
\begin{verbatim}
DecryptStage:
  MOV ESI, SelectedEncryptedBlock
  MOV EDI, ExecBuffer
  MOV ECX, 5
DecryptLoop:
  XOR BYTE PTR [EDI], BYTE PTR [ESI]
  INC ESI
  INC EDI
  LOOP DecryptLoop
  JMP ExecBuffer
\end{verbatim}
\end{LTR}

\bigskip\hrule\bigskip

\subsection*{مرحلهٔ ۴: اجرای نسخهٔ تولیدشده}


\begin{LTR}
\begin{verbatim}
MOV EAX, 100
ADD EAX, 20
RET
\end{verbatim}
\end{LTR}
